"""Watches the RC car for movement."""
from collections import deque
import argparse
import atexit
import datetime
import math
import os
import socket
import subprocess
import sys
import time

from common import format_command
from common import server_up

# pylint: disable=superfluous-parens
# pylint: disable=global-statement


CHANNELS_49_MHZ = (49.830, 49.845, 49.860, 49.875, 49.890)
CHANNELS_27_MHZ = (26.995, 27.045, 27.095, 27.145, 27.195, 27.255)


def normalize(img, bit_depth=None):
    """Linear normalization and conversion to grayscale of an image."""
    from PIL import ImageOps
    img = ImageOps.grayscale(img)
    img = ImageOps.autocontrast(img)
    if bit_depth is not None:
        img = ImageOps.posterize(img, bit_depth)
    return img


def mean(values):
    """Calculate mean of the values."""
    return sum(values) / len(values)


def standard_deviation(values, mean_=None):
    """Calculate standard deviation."""
    if mean_ is None:
        mean_ = mean(values)
    size = len(values)
    sum_ = 0.0
    for value in values:
        sum_ += math.sqrt((value - mean_) ** 2)
    return math.sqrt((1.0 / (size - 1)) * (sum_ / size))


def get_picture_from_command(command_tuple, crop_box=None):
    """Saves a picture from stdout generated by running the command."""
    from PIL import Image
    import StringIO

    # Use pipes to avoid writing to the disk
    pipe = subprocess.Popen(command_tuple, stdout=subprocess.PIPE)

    file_buffer = StringIO.StringIO(pipe.stdout.read())
    pipe.stdout.close()
    image = Image.open(file_buffer)
    if crop_box is not None:
        image = image.crop(crop_box)
    return image


def percent_difference(image_1, image_2):
    """Returns the percent difference between two images."""
    assert image_1.mode == image_2.mode, 'Different kinds of images.'
    assert image_1.size == image_2.size, 'Different sizes.'

    pairs = zip(image_1.getdata(), image_2.getdata())
    if len(image_1.getbands()) == 1:
        # for gray-scale jpegs
        diff = sum(abs(p1 - p2) for p1, p2 in pairs)
    else:
        diff = sum(abs(c1 - c2) for p1, p2 in pairs for c1, c2 in zip(p1, p2))

    ncomponents = image_1.size[0] * image_1.size[1] * 3
    return (diff / 255.0 * 100.0) / ncomponents


def get_process_command_lines():
    """Returns all of the command lines of running proceses on the system."""
    pids = [pid for pid in os.listdir('/proc') if pid.isdigit()]

    command_lines = []
    for pid in pids:
        try:
            command_lines.append(
                open(os.path.join('/proc', pid, 'cmdline'), 'rb').read()
            )
        except IOError:  # proc has already terminated
            continue

    return command_lines


def command_iterator(frequency):
    """Iterates through the frequencies and commands."""
    for useconds in range(100, 1201, 100):
        for sync_multiplier in range(2, 7):
            for sync_repeats in range(2, 7):
                for signal_repeats in range(5, 50):
                    yield (
                        frequency,
                        useconds,
                        sync_multiplier,
                        sync_repeats,
                        signal_repeats,
                    )


def search_for_command_codes(
    host,
    port,
    frequencies,
    get_picture_function=None,
    bit_depth=None
):
    """Iterates through commands and looks for changes in the webcam."""
    if get_picture_function is not None:
        diffs = deque()
        pictures = deque()

        base = normalize(get_picture_function(), bit_depth=bit_depth)
        try:
            base.save('normalized-test.png')
        except:
            pass
        time.sleep(1)
        print('Filling base photos for difference analysis')
        for _ in range(20):
            recent = normalize(get_picture_function(), bit_depth=bit_depth)
            diff = percent_difference(base, recent)
            time.sleep(1)
            diffs.append(diff)
            pictures.append(recent)

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    print(
        'Searching for command codes on {frequencies}'.format(
            frequencies=', '.join((str(f) for f in frequencies))
        )
    )
    command_tuple_description = ('freq', 'useconds', 'multiplier', 'sync_repeats', 'signal_repeats')
    for frequency in frequencies:
        for command_tuple in command_iterator(frequency):
            # pylint: disable=star-args
            command = format_command(*command_tuple)
            if sys.version_info.major == 3:
                command = bytes(command, 'utf-8')
            sock.sendto(command, (host, port))
            time.sleep(1)

            if get_picture_function is None:
                print(
                    ' '.join((
                        (desc + ':' + str(value)) for desc, value in zip(
                            command_tuple_description,
                            command_tuple
                        )
                    ))
                )
            else:
                recent = normalize(
                    get_picture_function(),
                    bit_depth=bit_depth
                )
                # Let's compare the most recent photo to the oldest one, in case a
                # cloud passes over and the brightness changes
                diff = percent_difference(pictures[0], recent)
                std_dev = standard_deviation(diffs)
                mean_ = mean(diffs)
                # I should be doing a z-test or something here... eh
                if abs(diff - mean_) > (std_dev * 3.0) and diff > 2.0:
                    print('Found substantially different photo, saving...')
                    print(
                        'diff={diff}, mean={mean}, std dev={std_dev}'
                        ' at {time}'.format(
                            diff=diff,
                            mean=mean_,
                            std_dev=std_dev,
                            time=str(datetime.datetime.now())
                        )
                    )
                    file_name = '-'.join(
                        (desc + '-' + str(value)) for desc, value in zip(
                            command_tuple_description,
                            command_tuple
                        )
                    )
                    try:
                        image = get_picture_function()
                        image.save(file_name + '.png')
                    except Exception as e:
                        print(file_name)
                        print('Unable to save photo: ' + str(e))
                    time.sleep(2)

                diffs.popleft()
                diffs.append(diff)
                pictures.popleft()
                pictures.append(recent)


def make_parser():
    """Builds and returns an argument parser."""
    parser = argparse.ArgumentParser(
        description='Iterates through and broadcasts command codes and'
            ' monitors the webcam to watch for movement from the RC car.'
    )

    parser.add_argument(
        '-p',
        '--port',
        dest='port',
        help='The port to send control commands to.',
        default=12345,
        type=int
    )
    parser.add_argument(
        '-s',
        '--server',
        dest='server',
        help='The server to send control commands to.',
        default='127.1'
    )

    parser.add_argument(
        '-f',
        '--frequency',
        dest='frequency',
        help='The frequency to broadcast commands on.',
        default=49,
        type=float
    )

    def bit_depth_checker(bit_depth):
        """Checks that the bit depth argument is valid."""
        try:
            bit_depth = int(bit_depth)
        except:
            raise argparse.ArgumentTypeError('Bit depth must be an int')

        if not 1 <= bit_depth <= 8:
            raise argparse.ArgumentTypeError(
                'Bit depth must be between 1 and 8 inclusive'
            )

        return bit_depth

    parser.add_argument(
        '-b',
        '--bit-depth',
        dest='bit_depth',
        help='The bit depth to reduce images to.',
        type=bit_depth_checker,
        default=1
    )

    parser.add_argument(
        '--no-camera',
        dest='no_camera',
        help='Disable the camera and image recognition. You will need to watch the RC car manually.',
        action='store_true',
        default=False
    )

    parser.add_argument(
        '--raspberry-pi-camera',
        dest='raspi_camera',
        help='Force the use of the Raspberry Pi camera.',
        action='store_true'
    )
    parser.add_argument(
        '--webcam',
        dest='webcam',
        help='Force the use of a webcam.',
        action='store_true'
    )

    return parser


def main():
    """Parses command line arguments and runs the interactive controller."""
    parser = make_parser()
    args = parser.parse_args()

    # Remove the default image to make sure that we're not processing images
    # from a previous run
    try:
        os.remove('photo.png')
    except OSError:
        pass

    if not server_up(args.server, args.port, args.frequency):
        print(
'''Server does not appear to be listening for messages, aborting.
Did you run pi_pcm?'''
        )
        return

    if not args.no_camera:
        try:
            import PIL
        except ImportError as e:
            sys.stderr.write(
'''Using the camera to detect movement requires the Python PIL libraries. You
can install them by running:
    apt-get install python-imaging
Or, you can use the `--no-camera` option and just watch the RC car for
movement. When it does, hit <Ctrl> + C and use the last printed values.
'''
            )
            sys.exit(1)

        if args.webcam and args.raspi_camera:
            sys.stderr.write(
                'You can only specify one of --webcam and --rasberry-pi-camera.'
            )
            sys.exit(1)
        if not args.webcam and not args.raspi_camera:
            # Find which to use
            raspi_exists = subprocess.call(
                ('/usr/bin/which', 'raspistill'),
                stdout=open('/dev/null', 'w')
            )
            if raspi_exists == 0:
                raspi_camera = True
            else:
                raspi_camera = False
            webcam = not raspi_camera

    # RC cars in the 27 and 49 MHz spectrum typically operate on one of a
    # several channels in that frequency, but most toy RC cars that I've
    # seen only list the major frequency on the car itself. If someone
    # enters a major frequency, search each channel.
    if args.frequency == 49:
        frequencies = CHANNELS_49_MHZ
    elif args.frequency == 27:
        frequencies = CHANNELS_27_MHZ
    else:
        frequencies = [args.frequency]

    print('Sending commands to ' + args.server + ':' + str(args.port))
    try:
        if args.no_camera:
            picture_function = None
        elif webcam:
            print('Using images from webcam')
            picture_function = lambda: get_picture_from_command(
                ('streamer', '-f', 'jpeg', '-s', '640x480', '-o', '/dev/stdout')
            )
        elif raspi_camera:
            print('Using images from Raspberry Pi camera')
            picture_function = lambda: get_picture_from_command(
                ('raspistill', '-w', '640', '-h', '480', '-t', '100', '-o', '-')
            )
        else:
            print('Not using camera')
            picture_function = None

        search_for_command_codes(
            args.server,
            args.port,
            frequencies,
            get_picture_function=picture_function,
            bit_depth=args.bit_depth,
        )
    # pylint: disable=broad-except
    except Exception as exc:
        print('Caught exception, exiting')
        print(str(exc))


if __name__ == '__main__':
    main()
